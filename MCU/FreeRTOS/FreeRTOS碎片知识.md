1. 任务里面的延时函数只能使用FreeRTOS中提供的延时函数vTaskDelay，理由是只有使用该函数，系统才能在该任务在延时状态时运行其他任务。
2. 任务必须是一个死循环，否则任务将通过LR返回，如果LR指向了非法的内存就会产生HardFault_Handler。
3. 使用静态创建任务时，需将宏`configSUPPORT_STATIC_ALLOCATION`定义为1。
4. 必须由用户自己实现两个函数`vApplicationGetIdleTaskMemory()`和`vApplicationGetTimerTaskMemory()`，这两个函数是用户设定的空闲任务与定时器任务的堆栈大小，必须由用户自己分配。
5. 如果没有就绪的用户任务，系统将会执行空闲任务，其功能是系统内存清理。
6. 栈空间地址对齐的大小是8字节。
7. 任务创建所需要的准备工作：
	1. 任务函数
	2. 堆栈
	3. 任务控制块
8. 任务静态创建函数`xTaskCreateStatic()`将任务函数、任务栈、任务控制块联系在一起。
9. 使用任务创建函数创建好任务后，任务处于就绪状态。
10. 任务调度器只需启用一次（vTaskStartScheduler）。
11. 关于malloc，FreeRTOS的做法是在SRAM里面定义一个大数组，也就是堆内存，供FreeRTOS的动态内存分配函数使用。
12. 如果宏`configUSE_TIME_SLICING`定义为1，则处于就绪态的多个相同优先级任务将会以时间片切换的方式共享处理器。
13. 时间片轮转调度仅在当前系统中无更高优先级就绪任务存在的情况下才有效。
14. 任务调度的原则是一旦任务状态发生了改变，并且当前运行的任务优先级小于优先级队列组中任务最高优先级时，立刻进行任务切换。
15. 调用了多少次的vTaksSuspendAll函数就要调用多少次的xTaskResumeAll函数进行恢复
16. xTaskResumeFromISR不能用于任务和中断间的同步，如果中断恰巧在任务被挂起之前到达就会导致一次中断丢失（任务还么有挂起，调用xTaskResumeFromISR函数是没有意义的）。
17. vTaskDelay的延时是相对的，相对是指的vTaskDelay的延时基准就指调用该函数的那一时刻，而且有可能在延时到了后被高优先级的任务打断。
18. 在中断中不能使用挂起当前任务的操作，也不允许调用任何会堵塞运行的API函数接口。
19. 事件链表按任务优先级排序。
20. 对公共变量的操作都需要开临界段。
21. 互斥量与二值信号量最大的不同是：互斥量具有优先级继承机制，即当某个临界资源收到互斥量保护时，假如有一个优先级更高的任务要获取该互斥量，就会因为当前拥有该互斥量的任务被系统强行拉升的最高级别导致获取失败。
22. 优先级翻转：低优先级任务占用资源时，高优先级任务无法获取而堵塞。
23. 互斥量应用场景：可能会引起优先级翻转的情况
24. 递归互斥量：任务可能会多次获取互斥量的情况下，这样可以避免同一任务多次递归持有而造成死锁的问题。
25. 